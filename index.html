<!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8">
            <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no' />
            <title>SWY</title>
            <!-- bar chart -->
            <link rel="stylesheet" href="css/class.css" />
            <!-- Leaflet -->
            <link rel="stylesheet" href="css/leaflet.css" />
            <link rel="stylesheet" href="css/leaflet-sidebar.css" />
            <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">

            <script src="lib/leaflet.js"></script>
            <script src="lib/leaflet.groupedlayercontrol.min.js"></script>
            <script src="src/colorMapLegend.js"></script>
            <script src="src/colorDefs.js"></script>

            <style>
                body { margin:0; padding:0; }
                body, table, tr, td, th, div, h1, h2, input { font-family: "Calibri", "Trebuchet MS", "Ubuntu", Serif; font-size: 11pt; }
                #map { position:absolute; top:0; bottom:0; width:100%; } /* full size */
                .ctl {
                    padding: 2px 10px 2px 10px;
                    background: white;
                    background: rgba(255,255,255,0.9);
                    box-shadow: 0 0 15px rgba(0,0,0,0.2);
                    border-radius: 5px;
                    text-align: right;
                }
                .title {
                    font-size: 18pt;
                    font-weight: bold;
                }
                .src {
                    font-size: 10pt;
                }

            </style>

        </head>
        <body>
          <script src='lib/topojson.min.js'></script>
          <script src="lib/d3.min.js"></script>
          <script src="lib/leaflet-sidebar.js"></script>
          <script src="lib/jquery-3.3.1.min.js"></script>

          <div id="sidebar" class="sidebar collapsed" name="sidebarName">
            <!-- Nav tabs -->
            <div class="sidebar-tabs">
                <ul role="tablist">
                    <li><a href="#home" role="tab"><i class="fa fa-bars"></i></a></li>
                </ul>

                <ul role="tablist">
                    <li><a href="#settings" role="tab"><i class="fa fa-cog"></i></a></li>
                </ul>
            </div>

            <!-- Tab panes -->
            <div class="sidebar-content">
                <div class="sidebar-pane" id="home">
                    <h1 class="sidebar-header">
                        Control panel
                        <span class="sidebar-close"><i class="fa fa-caret-left"></i></span>
                    </h1>
                    <h1> Data </h1>
                    <input type="radio" name="myRadios" value="0"> BaseFlow for historical climate <br>
                    <input type="radio" name="myRadios" value="1"> Flow retention for historical climate </br>
                    <input type="radio" name="myRadios" value="null"> Nothing </br>
                </div>

                <div class="sidebar-pane" id="settings">
                    <h1 class="sidebar-header">Settings<span class="sidebar-close"><i class="fa fa-caret-left"></i></span></h1>
                    <h1>Hide/Show statistics</h1>
                    <input type="checkbox" id="hideStats" value="0">Hide statistics<br>
                </div>
            </div>
          </div>
          <div id="map" class="sidebar-map"></div>

        <script>

        /* **** Leaflet **** */

        // Base layers
        //  .. OpenStreetMap
        d3.geoPath();
        var osm = L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'});

        //  .. CartoDB Positron
        var cartodb = L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="http://cartodb.com/attributions">CartoDB</a>'});

        //  .. OSM Toner
        var toner = L.tileLayer('http://{s}.tile.stamen.com/toner/{z}/{x}/{y}.png', {attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.'});

        //  .. White background
        var white = L.tileLayer("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEX///+nxBvIAAAAH0lEQVQYGe3BAQ0AAADCIPunfg43YAAAAAAAAAAA5wIhAAAB9aK9BAAAAABJRU5ErkJggg==");

        // Overlay layers (TMS)
        // Add here the new layouts
        var lyr0 = L.tileLayer('data/B_historical_change/{z}/{x}/{y}.png', {tms: true, opacity: 0.8, attribution: ""});
        var lyr1 = L.tileLayer('data/B_flow_retention/{z}/{x}/{y}.png', {tms: true, opacity: 0.8, attribution: ""});

        // Map
        var map = L.map('map', {
            center: [19.2436590371, 96.8861699425],
            zoom: 9,
            minZoom: 4,
            maxZoom: 9,
            layers: [osm]
        });

        var basemaps = {"OpenStreetMap": osm, "CartoDB Positron": cartodb, "Stamen Toner": toner, "Without background": white};

        map.on('baselayerchange', function(e) {
          currentLayer.bringToFront();
        });

        // Title
        var title = L.control();
        title.onAdd = function(map) {
	        this._div = L.DomUtil.create('div', 'ctl title');
	        this.update();
	        return this._div;
        };
        title.update = function(props) {
	        this._div.innerHTML = "Outputs Seasonal Water Yield Myanmar";
        };
        title.addTo(map);

        // Note
        var src = 'Generated by <a href="http://www.klokan.cz/projects/gdal2tiles/">GDAL2Tiles</a>, Copyright &copy; 2008 <a href="http://www.klokan.cz/">Klokan Petr Pridal</a>,  <a href="http://www.gdal.org/">GDAL</a> &amp; <a href="http://www.osgeo.org/">OSGeo</a> <a href="http://code.google.com/soc/">GSoC</a>';
        var title = L.control({position: 'bottomleft'});
        title.onAdd = function(map) {
	        this._div = L.DomUtil.create('div', 'ctl src');
	        this.update();
	        return this._div;
        };
        title.update = function(props) {
	        this._div.innerHTML = src;
        };
        title.addTo(map);

         // Use the custom grouped layer control, not "L.control.layers"
        L.control.layers(basemaps, null).addTo(map);

        // Remove the stupid leaflet copyright from bottom right

        let stupid_element = document.querySelector('.leaflet-control-attribution.leaflet-control');
        stupid_element.parentNode.removeChild(stupid_element);

        // End of switcher control.

        var sidebar = L.control.sidebar('sidebar').addTo(map);

        // Initialization of statistics plotting
        const height_stat = 200;
        const height_brush = 50;
        const height_tick = 18;
        const height_total = height_stat + height_brush + height_tick + 100;
        const width = 400;
        const margin = {
            top: 30,
            right: 30,
            bottom: 30,
            left: 50
        };
        const color = 'steelblue';

        // Build statistics svg
        stat_svg = d3.select('.leaflet-bottom.leaflet-right')
                        .append('svg')
                        .attr('width', width + margin.left + margin.right)
                        .attr('height', height_total + margin.top + margin.bottom);

        // Build a background rect
        back_rect = stat_svg.append('rect')
                                .attr('width', width + margin.left + margin.right)
                                .attr('height', height_total + margin.top + margin.bottom)
                                .attr('fill', 'white')
                                .attr('opacity', 0.6);

        // Add statistics name
        stat_svg.append('text')
                .text('Statistics')
                .attr('fill', 'black')
                .attr('font-size', 25)
                .attr('transform', 'translate(10, 120)');

        // Build statistics brush group
        let stat_brush_g = stat_svg.append('g')
                                    .attr('id', 'stat_brush_group')
                                    .attr('transform',
                                        'translate(' + margin.left + ',' + (margin.top + height_total - height_brush) + ')');

        // Build brush background rectangle
        let brush_rect = stat_brush_g.append('rect')
                                    .attr('id', 'brush_rect')
                                    .attr('width', width)
                                    .attr('height', height_brush)
                                    .attr('stroke-width', 1)
                                    .attr('stroke', 'red')
                                    .attr('fill', 'blue')
                                    .attr('fill-opacity', 0.1);

        // Add brush name
        stat_svg.append('text')
                    .text('Brush')
                    .attr('fill', 'black')
                    .attr('transform', 'translate(0,' + (height_total + margin.top - height_brush + 10) + ')')
                    .attr('font-size', 18);


        createD3LegendBox(stat_svg, 0);

        // Add province name group
        let prov_name_g = stat_svg.append('g')
                                    .attr('transform', 'translate(' + (margin.left + width - 20) + ',50)')
                                    .attr('width', 20 + margin.right);

        // Add canton border to the map
        let svg = d3.select(map.getPanes().overlayPane).append('svg').attr('id', 'svg');
        let g = svg.append('g').attr('class', 'leaflet-zoom-hide');

        // Map promise
        const map_promise = d3.json('map/MYANMAR_GEOJSON.json').then(x => x);

        // Define project point function
        function project_point(x, y){
            let point = map.latLngToLayerPoint(new L.LatLng(y, x));
            this.stream.point(point.x, point.y);
        }

        let canton = null;
        // load json
        // var json_ = $.getJSON('data/stat.json');
        let stat = d3.json("./data/stat.json").then(d => d);

        // load statistics json
        const full_stat = d3.json('./prov_data.json').then(d => d);
        
        let transform = d3.geoTransform({point: project_point});
        let gen_path = d3.geoPath().projection(transform);

        Promise.all([map_promise, full_stat]).then((results) => {
            let feature = g.selectAll('path')
                            .data(results[0].features)
                            .enter()
                                .append('path')
            feature.attr('d', gen_path)
                    .attr('fill-opacity', 0)
                    .attr('postion', 'relative')
                    .attr('stroke', 'green')
                    .attr('stroke-width', 2)
                    .attr('stroke-opacity', 0.5)
                    .on('mousedown.log', (d) => {

                        // Set the canton
                        canton = d.properties['NAME_1'];
                        console.log(d.properties['NAME_1']);

                        // Draw the statistics of canton

                        // Get statistics

                        stat_results = results[1];
                        console.log(stat_results);
                        let bins = stat_results['bins'][canton];
                        let counts = stat_results['full_disc_data_counts'][canton];

                        let max_count = Math.max.apply(Math, counts);

                        // Build bin-count dict
                        // Build test data

                        // construct x y and color scale
                        let y_scale = d3.scaleLinear()
                                                .domain([0, max_count])
                                                .range([height_stat, 0]);
                        console.log('Max count', max_count);
                        let x_scale = d3.scaleLinear()
                                                .domain([0, bins.length])
                                                .range([0, width]);
                        let color_scale = d3.scaleLinear()
                                                .domain([0, max_count])
                                                .range([d3.rgb(color).brighter(),
                                                        d3.rgb(color).darker()]);
                        // Plot the bar chart

                        // Remove old info
                        stat_svg.select('.stat_group')
                                    .remove();
                        prov_name_g.select('#prov_name')
                                    .remove()
                        stat_svg.select('#stat_brush_group')
                                    .remove();
                        // Plot new info
                        prov_name_g.append('text')
                                    .text(canton)
                                    .attr('font-size', 20)
                                    .attr('color', 'black')
                                    .attr('text-anchor', 'end')
                                    .attr('id', 'prov_name');

                        // Build statistics group
                        let stat_g = stat_svg.append('g')
                                        .attr('class', 'stat_group')
                                        .attr('id', '#stat_group')
                                        .attr('transform',
                                            'translate(' + margin.left + ',' + (margin.top + height_total - height_stat - height_tick - height_brush) + ')');
                        
                        // Build statistics plot group
                        let stat_plot_g = stat_g.append('g')
                                                    .attr('id', 'stat_plot_group');

                        // Rebuild statistics brush group
                        let stat_brush_g = stat_svg.append('g')
                                                    .attr('id', 'stat_brush_group')
                                                    .attr('transform',
                                                        'translate(' + margin.left + ',' + (margin.top + height_total - height_brush) + ')');

                        // Rebuild brush background rectangle
                        let brush_rect = stat_brush_g.append('rect')
                                                    .attr('id', 'brush_rect')
                                                    .attr('width', width)
                                                    .attr('height', height_brush)
                                                    .attr('stroke-width', 1)
                                                    .attr('stroke', 'red')
                                                    .attr('fill', 'blue')
                                                    .attr('fill-opacity', 0.1);

                        // Plot rectangles
                        let bar_width = width / bins.length;

                        
                        let bars = stat_plot_g.selectAll('g')
                                .data(counts)
                                .enter()
                                    .append('g')
                                    .attr('transform',
                                        (d, i) => 'translate(' +
                                         x_scale(i + 0.5) + ',' + 0 + ')');

                        bars.append('rect')
                                .attr('y', (d, i) => y_scale(d))
                                .attr('height', (d, i) => 
                                    height_stat - y_scale(d))
                                .attr('width', bar_width - 0.2)
                                .attr('fill', (d) => color_scale(d));
                        console.log(bar_width);
                        // Add axis to the bar chart
                        let x_axis_scale = d3.scaleLinear()
                                                    .domain([bins[0], bins[bins.length - 1]])
                                                    .range([0, width]);
                        let x_axis = d3.axisBottom()
                                            .scale(x_axis_scale);

                        let x_axis_g = stat_g.append('g')
                                        .attr('transform', 'translate(0,' + height_stat + ')')
                                        .call(x_axis);

                        const y_axis = d3.axisLeft()
                                            .scale(y_scale);
                        stat_g.append('g')
                                .call(y_axis);

                        // Build brush for zooming
                        let stat_brushX = d3.brushX()
                                            .extent([[0, 0],
                                                [width, height_brush]])
                                            .on('end', (e) => {
                                                L.DomEvent.stopPropagation(d3.event);
                                                console.log(d3.event.selection);
                                                let sel_result = d3.event.selection;
                                                let new_domain; 
                                                let new_index;
                                                if (sel_result === null){
                                                    // define restoration to base case event
                                                    new_domain = [bins[0], bins[bins.length - 1]];
                                                    new_index = new_domain.map(x => x / 100 + counts.length / 2);
                                                }
                                                else{
                                                    // define rescale event
                                                    new_domain = sel_result.map(x_axis_scale.invert);
                                                    // convert new domain to interger
                                                    new_domain = new_domain.map(x => Math.floor(x / 100) * 100);
                                                    // get new index
                                                    new_index = new_domain.map(x => x / 100 + counts.length / 2);
                                                }
                                                // Set up new x-scale and x-axis-scale
                                                // That is because x are indices while axis are real numbers
                                                x_axis_scale.domain(new_domain);
                                                x_scale.domain(new_index.map(x => x - new_index[0]));

                                                // Set up new x-axis
                                                x_axis.scale(x_axis_scale);
                                                x_axis_g.call(x_axis);
                                        
                                                // Create new bar width
                                                bar_width = width / (new_index[1] - new_index[0] + 1);

                                                // Clear old rectangles
                                                stat_plot_g.selectAll('g')
                                                            .data([])
                                                            .exit()
                                                            .remove();

                                                // Add new rectangles
                                                stat_plot_g.selectAll('g')
                                                            .data(counts.slice(new_index[0],
                                                                        new_index[1]))
                                                            .enter()
                                                                .append('g')
                                                                .attr('transform', (d, i) => 'translate(' + x_scale(i + 1) + ',0)');

                                                stat_plot_g.selectAll('g')
                                                    .append('rect')
                                                    .attr('y', (d) => y_scale(d))
                                                    .attr('width', bar_width - 0.2)
                                                    .attr('height', (d) => height_stat - y_scale(d))
                                                    .attr('fill', (d) => color_scale(d));

                                                // Restore map functions
                                                map.dragging.enable();
                                                map.touchZoom.enable();
                                                map.doubleClickZoom.enable();
                                                map.scrollWheelZoom.enable();
                                                map.boxZoom.enable();
                                                map.keyboard.enable();
                                                if (map.tap) map.tap.enable();
                                                document.getElementById('map').style.cursor='grab';
                                            });

                        // Prevent map from moving while we are focused on brushing
                        stat_brushX.on('brush', function(){
                                                    map.dragging.disable();
                                                    map.touchZoom.disable();
                                                    map.doubleClickZoom.disable();
                                                    map.scrollWheelZoom.disable();
                                                    map.boxZoom.disable();
                                                    map.keyboard.disable();
                                                    if (map.tap) map.tap.disable();
                                                    document.getElementById('map').style.cursor='default';});
                        stat_brush_g.call(stat_brushX);

                    });

            let bounds = gen_path.bounds(results[0]);
            let top_left = bounds[0];
            let bottom_right = bounds[1];

            svg.attr('width', bottom_right[0] - top_left[0])
                .attr('height', bottom_right[1] - top_left[1])
                .style('left', top_left[0] + 'px')
                .style('top', top_left[1] + 'px');

            g.attr('transform', 'translate(' + -top_left[0] + ',' + -top_left[1] + ')');


            map.on('moveend', () => {
                bounds = gen_path.bounds(results[0]);
                top_left = bounds[0];
                bottom_right = bounds[1];
                svg.attr('width', bottom_right[0] - top_left[0])
                    .attr('height', bottom_right[1] - top_left[1])
                    .style('left', top_left[0] + 'px')
                    .style('top', top_left[1] + 'px');

                g.attr('transform', 'translate(' + -top_left[0] + ',' + -top_left[1] + ')');
                feature.attr('d', gen_path);
            });

        });
	
	var popup = L.popup();
        // Response to the mouse click
        map.on('click', function(e) {
            // alert("Lat, Lon : " + e.latlng.lat + ", " + e.latlng.lng);
	        // console.log("wait for server");

            var xhr = new XMLHttpRequest();
            var url = "https://35.243.179.153";
	        //var url = "http://10.142.0.2:5000/";
            var data = {'lat': e.latlng.lat, 'lin': e.latlng.lng};
            xhr.open("POST", url, true);
            xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded");
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4 && xhr.status == 200) {
                    // do something with response
                    if (canton != null){
                        popup.setLatLng(e.latlng)
                        .setContent("Position " + e.latlng.toString() + '\nCanton is ' + canton.toString() + '\nValue is ' + xhr.responseText.toString())
                        .openOn(map)
                        canton = null
                    }
                    else {
                        popup.setLatLng(e.latlng)
                        .setContent("Position " + e.latlng.toString() + '\nValue is ' + xhr.responseText.toString())
                        .openOn(map)
                    }
                    console.log(popup)
                    console.log(xhr.responseText);
                }
            };
            xhr.send(JSON.stringify(data));
        });

        // Declare radiobuttons listeners
        let radioButtons = document.getElementsByName("myRadios");
        radioButtons[0].checked = true;
        let prev = {
          value: "0"
        };
        map.addLayer(lyr0);
        let currentLayer = eval("lyr" + prev.value);

        for(var i = 0; i < radioButtons.length; i++) {
          radioButtons[i].addEventListener('change', function() {
            if(this.value !== "null") {
              if(currentLayer !== undefined) {
                map.removeLayer(eval("lyr" + prev.value));
              };

              prev = this;
              currentLayer = eval("lyr" + this.value);
              map.addLayer(currentLayer);
              currentLayer.bringToFront();
              createD3LegendBox(stat_svg, parseInt(this.value, 10));
            }
            if(this.value === "null") {
              map.removeLayer(currentLayer);
              currentLayer = undefined;
              removeColorBar();
            }
          });
        }

        // Declare checkbox listeners
        let checkboxHideStats = document.getElementById("hideStats");
        checkboxHideStats.addEventListener('change', () => {
          if(checkboxHideStats.checked) {
            // hide stats;
            stat_svg.attr("visibility", "hidden");
          } else {
            // show stats
            stat_svg.attr("visibility", "visible");
          }
        });

        // Fit to overlay bounds (SW and NE points with (lat, lon))
        map.fitBounds([[9.92035336588, 101.633885799], [28.5669647084, 92.1384540862]]);

        </script>

        </body>
        </html>
s
