<!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="utf-8">
            <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no' />
            <title>SWY</title>
            <!-- bar chart -->
            <link rel="stylesheet" href="css/autocomplete.css" />
            <link rel="stylesheet" href="css/timeline.css" />

            <!-- Leaflet -->
            <link rel="stylesheet" href="css/leaflet.css" />
            <link rel="stylesheet" href="css/leaflet-sidebar.css" />
            <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
            <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css">

            <link href="css/bootstrap-tabs-x-bs4.css" media="all" rel="stylesheet" type="text/css" />

            <script src="lib/leaflet.js"></script>
            <script src="lib/leaflet.groupedlayercontrol.min.js"></script>
            <script src="src/colorMapLegend.js"></script>
            <script src="src/colorDefs.js"></script>
            <script src="lib/leaflet-heat.js"></script>
            <script src="lib/jquery-3.3.1.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.11.0/umd/popper.min.js"></script>
            <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/js/bootstrap.min.js" type="text/javascript"></script>
            <script src="lib/bootstrap-tabs-x.min.js" type="text/javascript"></script>

            <style>
                body { margin:0; padding:0; }
                body, table, tr, td, th, div, h1, h2, input { font-family: "Calibri", "Trebuchet MS", "Ubuntu", Serif; font-size: 11pt; }
                #map { position:absolute; top:0; bottom:0; width:100%;} /* full size */
                .ctl {
                    padding: 2px 10px 2px 10px;
                    background: white;
                    background: rgba(255,255,255,0.9);
                    box-shadow: 0 0 15px rgba(0,0,0,0.2);
                    border-radius: 5px;
                    text-align: right;
                }
                .title {
                    font-size: 18pt;
                    font-weight: bold;
                }
                .src {
                    font-size: 10pt;
                }

                .split {
                    float:left !important;
                    height: 100% !important; 
                    width: 33.33% !important;
                    border: 1px  dashed;
                  }

                  /* Control the left side */
                  .left {
                    left: 0;
                    background-color: #111;
                  }

                  /* Control the right side */
                  .right {
                    right: 0;
                    background-color: red;
                  }


            </style>

        </head>
        <body>
          <script src='lib/topojson.min.js'></script>
          <script src="lib/d3.min.js"></script>
          <script src="lib/leaflet-sidebar.js"></script>

          <div id="sidebar" class="leaflet-sidebar">
            <!-- Nav tabs -->
            <div class="leaflet-sidebar-tabs">
              <ul role="tablist">
                <li><a href="#home" role="tab"><i class="fa fa-bars"></i></a></li>
              </ul>

              <ul role="tablist">
                <li><a href="#settings" role="tab"><i class="fa fa-cog"></i></a></li>
              </ul>
            </div>

            <!-- Tab panes -->
            <div class="leaflet-sidebar-content">

              <div class="leaflet-sidebar-pane" id="home">
                <h1 class="leaflet-sidebar-header">
                  Control panel
                  <span class="leaflet-sidebar-close"><i class="fa fa-caret-right"></i></span>
                </h1> </br>
                <div class="tabs-x align-center tabs-above tab-bordered" style="overflow:auto;height:400px">
                  <!-- tabs -->
                  <ul class="nav nav-tabs" id="myTab" role="tablist">
                     <li class="nav-item">
                          <a class="nav-link active" id="user-guidelines-tab" data-toggle="tab" href="#userGuidelines" role="tab" aria-controls="home" aria-expanded="tue"><div class="text-center"><span>User</br>Guidelines</span></div></a>
                     </li>
                     <li class="nav-item">
                          <a class="nav-link" id="profile-tab" data-toggle="tab" href="#profile" role="tab" aria-controls="profile"> <div class="text-center"><span>Overview<br/>&nbsp</span></div></a>
                     </li>
                     <li class="nav-item">
                          <a class="nav-link" id="canton-view-tab" data-toggle="tab" href="#cantonView" role="tab" aria-controls="cantonView"> <div class="text-center"><span>Canton<br/>View</span></div></a>
                     </li>
                     <li class="nav-item">
                          <a class="nav-link" id="timeline-tab" data-toggle="tab" href="#timelineView" role="tab" aria-controls="timelineView"> <div class="text-center"><span>Month<br/>View</span></div></a>
                     </li>
                  </ul>

                  <!-- tab panes -->
                  <div class="tab-content" id="myTabContent">
                   <div class="tab-pane fade show active" id="userGuidelines" role="tabpanel" aria-labelledby="user-guidelines-tab">
                     Give the user guidelines of the control panel.
                   </div>

                   <div class="tab-pane fade" id="profile" role="tabpanel" aria-labelledby="profile-tab">

                     <font size="+1"> Data </font> </br>
                     <input type="radio" name="myRadios" value="0"> BaseFlow for historical climate </br>
                     <input type="radio" name="myRadios" value="1"> Flow retention for historical climate </br>
                     <input type="radio" name="myRadios" value="null"> Nothing </br>

                     <font size="+1"> Heatmap </font> </br>
                     <input type="checkbox" id="increaseHeat" value="0"> Show increase </br>
                     <input type="checkbox" id="decreaseHeat" value="1"> Show decrease </br>
                   </div>

                   <div class="tab-pane fade" id="cantonView" role="tabpanel" aria-labelledby="canton-view-tab" style="height:100px">
                      <p>States in Myanmar</p>

                      <!--Make sure the form has the autocomplete function switched off:-->
                      <!-- <form autocomplete="off" action=> -->
                      <div class="autocomplete" style="width:150px;">
                        <input id="myInput" type="text" name="myCountry" placeholder="State" style="width:100px;height:25px">
                        <button style="position:absolute;height:25px;margin-left:5px" type="button" class="btn-success" onclick="getInput()">Search</button>
                      </div>

                   </div>

                   <div class="tab-pane fade" id="timelineView" role="tabpanel" aria-labelledby="timeline-tab">


                    <div id="vis">
                      <button id="play-button">Play</button>
                    </div>
                    <div>
                      <img src="http://www.endlessicons.com/wp-content/uploads/2012/11/reset-icon-614x460.png" id="reset" onclick = "Reset()" />
                    </div>

                   </div>

                 </div>

                </div>
              </div>
            </div>


              <div class="leaflet-sidebar-pane" id="settings">
                  <h1 class="leaflet-sidebar-header">Settings<span class="leaflet-sidebar-close"><i class="fa fa-caret-left"></i></span></h1>
                  <h1>Hide/Show statistics</h1>
                  <input type="checkbox" id="hideStats" value="0">Hide statistics<br>
              </div>
          </div>

          <!-- Divide the screen into three parts-->
          <div id="ctl_panel_div" class="split">
            <p style="font-size:20px">Control panel</p>
          </div>
          <div id="stat_div" class="split">
            <p style="font-size:20px">Statistics</p>
            <svg>
          </div>
          <div id="map" class="sidebar-map split" style="right:0 !important"></div>

        <script src='data/mapList.js'></script>
        <script src='js/d3v4.js'></script>
        <script src='js/autocomplete.js'></script>
        <script src='data/qf_historical_12months/qf1.js'></script>
        <script src='data/qf_historical_12months/qf2.js'></script>
        <script src='data/qf_historical_12months/qf3.js'></script>
        <script src='data/qf_historical_12months/qf4.js'></script>
        <script src='data/qf_historical_12months/qf5.js'></script>
        <script src='data/qf_historical_12months/qf6.js'></script>
        <script src='data/qf_historical_12months/qf7.js'></script>
        <script src='data/qf_historical_12months/qf8.js'></script>
        <script src='data/qf_historical_12months/qf9.js'></script>
        <script src='data/qf_historical_12months/qf10.js'></script>
        <script src='data/qf_historical_12months/qf11.js'></script>
        <script src='data/qf_historical_12months/qf12.js'></script>
        <script src='js/timeline.js'></script>
        <script src='js/fengyu.js'></script>

        <script>

        /* **** Leaflet **** */

        // Base layers
        //  .. OpenStreetMap
        d3.geoPath();
        var osm = L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'});

        //  .. CartoDB Positron
        var cartodb = L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="http://cartodb.com/attributions">CartoDB</a>'});

        //  .. OSM Toner
        var toner = L.tileLayer('http://{s}.tile.stamen.com/toner/{z}/{x}/{y}.png', {attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.'});

        //  .. White background
        var white = L.tileLayer("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEX///+nxBvIAAAAH0lEQVQYGe3BAQ0AAADCIPunfg43YAAAAAAAAAAA5wIhAAAB9aK9BAAAAABJRU5ErkJggg==");

        // Overlay layers (TMS)
        // Add here the new layouts
        var lyr0 = L.tileLayer('data/B_historical_change/{z}/{x}/{y}.png', {tms: true, opacity: 0.8, attribution: ""});
        var lyr1 = L.tileLayer('data/B_flow_retention/{z}/{x}/{y}.png', {tms: true, opacity: 0.8, attribution: ""});

        // Map
        var map = L.map('map', {
            center: [19.2436590371, 96.8861699425],
            zoom: 9,
            minZoom: 4,
            maxZoom: 9,
            layers: [osm]
        });

        var basemaps = {"OpenStreetMap": osm, "CartoDB Positron": cartodb, "Stamen Toner": toner, "Without background": white};

        map.on('baselayerchange', function(e) {
          currentLayer.bringToFront();
        });

        // Title
        var title = L.control();
        title.onAdd = function(map) {
	        this._div = L.DomUtil.create('div', 'ctl title');
	        this.update();
	        return this._div;
        };
        title.update = function(props) {
	        this._div.innerHTML = "Outputs Seasonal Water Yield Myanmar";
        };
        title.addTo(map);

        // Note
        var src = 'Generated by <a href="http://www.klokan.cz/projects/gdal2tiles/">GDAL2Tiles</a>, Copyright &copy; 2008 <a href="http://www.klokan.cz/">Klokan Petr Pridal</a>,  <a href="http://www.gdal.org/">GDAL</a> &amp; <a href="http://www.osgeo.org/">OSGeo</a> <a href="http://code.google.com/soc/">GSoC</a>';
        var title = L.control({position: 'bottomleft'});
        title.onAdd = function(map) {
	        this._div = L.DomUtil.create('div', 'ctl src');
	        this.update();
	        return this._div;
        };
        title.update = function(props) {
	        this._div.innerHTML = src;
        };
        title.addTo(map);

         // Use the custom grouped layer control, not "L.control.layers"
        L.control.layers(basemaps, null).addTo(map);

        // Remove the stupid leaflet copyright from bottom right

        let stupid_element = document.querySelector('.leaflet-control-attribution.leaflet-control');
        stupid_element.parentNode.removeChild(stupid_element);

        // End of switcher control.

        var sidebar = L.control.sidebar('sidebar', {
          position : "right",
          autopan : true
        }).addTo(map);
        sidebar.open('home');

        // Obtain the data for the sidebar
        let sidebar_element = d3.select('.leaflet-sidebar-content');
        console.log(sidebar_element);
        console.log('default width',sidebar_element.node().getBoundingClientRect().width);

        // Initialization of statistics plotting
        const margin = {
            top: 30,
            right: 30,
            bottom: 30,
            left: 50
        };
        const height_stat = 200;
        const height_brush = 50;
        const height_tick = 18;
        const panel_guide_height = 500;
        const sidebar_height = sidebar_element.node().getBoundingClientRect().height;
        const height_total = height_stat + height_brush + height_tick + 100;
        const width = sidebar_element.node().getBoundingClientRect().width - margin.right - margin.left;
        const svg_y = sidebar_height - height_total - margin.top - margin.bottom - panel_guide_height;
        const color = 'steelblue';

        // Build statistics svg
        stat_svg = d3.select('.leaflet-sidebar-content')
                        .append('svg')
                        .attr('transform', 'translate(0,' + svg_y + ')')
                        .attr('width', width + margin.left + margin.right)
                        .attr('height', height_total + margin.top + margin.bottom);

        // Build a background rect
        back_rect = stat_svg.append('rect')
                                .attr('width', width + margin.left + margin.right)
                                .attr('height', height_total + margin.top + margin.bottom)
                                .attr('fill', 'white')
                                .attr('opacity', 0.6);
    // Add statistics name
        stat_svg.append('text')
                .text('Histogram of Ouput Seasonal Water Yield')
                .attr('fill', 'black')
                .attr('font-size', 15)
                .attr('transform', 'translate(10, 120)');

        // Build statistics brush group
        let stat_brush_g = stat_svg.append('g')
                                    .attr('id', 'stat_brush_group')
                                    .attr('transform',
                                        'translate(' + margin.left + ',' + (margin.top + height_total - height_brush) + ')');

        // Build brush background rectangle
        let brush_rect = stat_brush_g.append('rect')
                                    .attr('id', 'brush_rect')
                                    .attr('width', width)
                                    .attr('height', height_brush)
                                    .attr('stroke-width', 1)
                                    .attr('stroke', 'red')
                                    .attr('fill', 'blue')
                                    .attr('fill-opacity', 0.1);

        // Add brush name
        stat_svg.append('text')
                    .text('Brush')
                    .attr('fill', 'black')
                    .attr('transform', 'translate(0,' + (height_total + margin.top - height_brush + 10) + ')')
                    .attr('font-size', 18);


        createD3LegendBox(stat_svg, 0);

        // Add province name group
        let prov_name_g = stat_svg.append('g')
                                    .attr('transform', 'translate(' + (margin.left + width - 20) + ',50)')
                                    .attr('width', 20 + margin.right);

        prov_name_g.append('text')
                        .text('Province')
                        .attr('dx', -50)
                        .attr('dy', -20)
                        .attr('text-anchor', 'middle')
                        .attr('font-size', 25);


        // Add canton border to the map
        let svg = d3.select(map.getPanes().overlayPane).append('svg').attr('id', 'svg');
        let g = svg.append('g').attr('class', 'leaflet-zoom-hide');

        // Map promise
        const map_promise = d3.json('map/MYANMAR_GEOJSON.json').then(x => x);

        // Define project point function
        function project_point(x, y){
            let point = map.latLngToLayerPoint(new L.LatLng(y, x));
            this.stream.point(point.x, point.y);
        }

        let canton = null;

        let stat = d3.json("./data/stat.json").then(d => d);

        // load statistics json
        const full_stat = d3.json('./data/prov_data.json').then(d => d);

        let transform = d3.geoTransform({point: project_point});
        let gen_path = d3.geoPath().projection(transform);


        Promise.all([map_promise, full_stat]).then((results) => {
            let feature = g.selectAll('path')
                            .data(results[0].features)
                            .enter()
                                .append('path')
            feature.attr('d', gen_path)
                    .attr('class', 'province')
                    .attr('fill-opacity', 0)
                    .attr('position', 'relative')
                    .attr('stroke', 'green')
                    .attr('stroke-width', 2)
                    .attr('stroke-opacity', 0.5)
                    .on('mousedown.log', (d) => {

                        // Set the canton
                        canton = d.properties['NAME_1'];
                        console.log(d.properties['NAME_1']);

                        // Draw the statistics of canton

                        // Get statistics

                        stat_results = results[1];
                        console.log(stat_results);
                        let bins = stat_results['bins'][canton];
                        let bin_size = bins[1] - bins[0];
                        let counts = stat_results['full_disc_data_counts'][canton];

                        let max_count = Math.max.apply(Math, counts);


                        // For better user experience we first zoom in to dense part
                        let init_index = bins.length / 2 - 20;
                        let init_length = 40;
                        let init_max_count = Math.max.apply(Math, counts.slice(init_index, init_index + init_length));
                        // construct x y and color scale
                        let y_scale = d3.scaleLinear()
                                                .domain([0, init_max_count])
                                                .range([height_stat, 0]);

                        let x_scale = d3.scaleLinear()
                                                .domain([0, init_length])
                                                .range([0, width]);

                        let color_scale = d3.scaleLinear()
                                                .domain([0, max_count])
                                                .range([d3.rgb(color).brighter(),
                                                        d3.rgb(color).darker()]);
                        // Plot the bar chart

                        // Remove old info
                        stat_svg.select('.stat_group')
                                    .remove();
                        prov_name_g.select('#prov_name')
                                    .remove()
                        stat_svg.select('#stat_brush_group')
                                    .remove();
                        // Plot new info
                        prov_name_g.append('text')
                                    .text(canton)
                                    .attr('font-size', 20)
                                    .attr('color', 'black')
                                    .attr('text-anchor', 'end')
                                    .attr('id', 'prov_name');

                        // Build statistics group
                        let stat_g = stat_svg.append('g')
                                        .attr('class', 'stat_group')
                                        .attr('id', '#stat_group')
                                        .attr('transform',
                                            'translate(' + margin.left + ',' + (margin.top + height_total - height_stat - height_tick - height_brush) + ')');
                        
                        // Build statistics plot group
                        let stat_plot_g = stat_g.append('g')
                                                    .attr('id', 'stat_plot_group');

                        // Rebuild statistics brush group
                        let stat_brush_g = stat_svg.append('g')
                                                    .attr('id', 'stat_brush_group')
                                                    .attr('transform',
                                                        'translate(' + margin.left + ',' + (margin.top + height_total - height_brush) + ')');

                        // Rebuild brush background rectangle
                        let brush_rect = stat_brush_g.append('rect')
                                                    .attr('id', 'brush_rect')
                                                    .attr('width', width)
                                                    .attr('height', height_brush)
                                                    .attr('stroke-width', 1)
                                                    .attr('stroke', 'red')
                                                    .attr('fill', 'blue')
                                                    .attr('fill-opacity', 0.1);

                        // Plot rectangles
                        let bar_width = width / init_length;

                        
                        let bars = stat_plot_g.selectAll('g')
                                .data(counts.slice(init_index, init_index + init_length))
                                .enter()
                                    .append('g')
                                    .attr('transform',
                                        (d, i) => 'translate(' +
                                         x_scale(i) + ',' + 0 + ')');

                        bars.append('rect')
                                .attr('y', (d, i) => y_scale(d))
                                .attr('height', (d, i) => 
                                    height_stat - y_scale(d))
                                .attr('width', bar_width)
                                .attr('fill', (d) => color_scale(d));
                        console.log(bins.length);

                        // Add axis to the bar chart
                        let x_axis_scale = d3.scaleLinear()
                                                    .domain([bins[init_index], bins[init_index + init_length]])
                                                    .range([0, width]);

                        let x_axis = d3.axisBottom()
                                            .scale(x_axis_scale);

                        let x_axis_g = stat_g.append('g')
                                        .attr('transform', 'translate(0,' + height_stat + ')')
                                        .call(x_axis);

                        // Add x_axis to brush
                        let brush_scale = d3.scaleLinear()
                                                .domain([bins[0], bins[bins.length - 1]])
                                                .range(x_axis_scale.range());

                        let brush_axis = d3.axisBottom()
                                            .scale(brush_scale);

                        let brush_axis_g = stat_g.append('g')
                                                    .attr('id', 'brush_axis_g')
                                                    .attr('transform', 'translate(0,' + (height_stat + 18 + height_brush) + ')')
                                                    .call(brush_axis);

                        // Add outlier indication 
                        brush_axis_g.append('g')
                                        .attr('text', '>' + max_count)
                                        .attr('transform', 'translate(' + width + ',' + (height_stat + height_brush + 25) + ')')
                                        .attr('font-size', 25)
                                        .attr('fill', 'black');

                        let y_axis = d3.axisLeft()
                                            .scale(y_scale);
                        let y_axis_g = stat_g.append('g')
                                            .attr('id', 'y_axis_g')
                                            .call(y_axis);

                        let stat_brushX = d3.brushX()
                                            .extent([[0, 0],
                                                [width, height_brush]])
                                            .on('end', function() {
                                                
                                                if (!d3.event.sourceEvent)
                                                    return;
                                                
                                                L.DomEvent.stopPropagation(d3.event);
                                                console.log(d3.event.selection);

                                                let sel_result = d3.event.selection;
                                                let new_domain; 
                                                let new_index;
                                                if (sel_result === null){
                                                    // define restoration to base case event
                                                    new_domain = [bins[0], bins[bins.length - 1]];
                                                    new_index = new_domain.map(x => x / bin_size + counts.length / 2);
                                                }
                                                else{
                                                    // define rescale event
                                                    new_domain = sel_result.map(brush_scale.invert);
                                                    // convert new domain to interger
                                                    new_domain = new_domain.map(x => Math.floor(x / bin_size) * bin_size);
                                                    // get new index
                                                    new_index = new_domain.map(x => x / bin_size + counts.length / 2);
                                                    new_index[1] -= 1;
                                                    console.log(new_domain);
                                                    console.log(new_index);
                                                }

                                                // Set up new x-scale and x-axis-scale
                                                // That is because x are indices while axis are real numbers
                                                x_axis_scale.domain(new_domain)
                                                            .ticks(new_index[1] - new_index[0] + 1);
                                                x_scale.domain([0, new_index[1] - new_index[0] + 1]);

                                                console.log("x_scale dom", x_scale.domain());
                                                // Set up new x-axis
                                                x_axis.scale(x_axis_scale);
                                                x_axis_g.call(x_axis);

                                                // Set up new y scale
                                                max_count = d3.max(counts.slice(new_index[0], new_index[1]));
                                                console.log(max_count);
                                                y_scale.domain([0, max_count]);
                                                y_axis.scale(y_scale);
                                                y_axis_g.call(y_axis);
                                                
                                                // Create new bar width
                                                bar_width = width / (new_index[1] - new_index[0] + 1);

                                                // Clear old rectangles
                                                stat_plot_g.selectAll('g')
                                                            .data([])
                                                            .exit()
                                                            .remove();

                                                // Add new rectangles
                                                stat_plot_g.selectAll('g')
                                                            .data(counts.slice(new_index[0],
                                                                        new_index[1]))
                                                            .enter()
                                                                .append('g')
                                                                .attr('transform', (d, i) => 'translate(' + x_scale(i) + ',0)');
                                                console.log(counts.slice(new_index[0], new_index[1]).length);
                                                console.log(new_domain[1] - new_domain[0]);

                                                stat_plot_g.selectAll('g')
                                                    .append('rect')
                                                    .attr('y', (d) => y_scale(d))
                                                    .attr('width', bar_width )
                                                    .attr('height', (d) => height_stat - y_scale(d))
                                                    .attr('fill', (d) => color_scale(d));


                                                // Restore map functions
                                                map.dragging.enable();
                                                map.touchZoom.enable();
                                                map.doubleClickZoom.enable();
                                                map.scrollWheelZoom.enable();
                                                map.boxZoom.enable();
                                                map.keyboard.enable();
                                                if (map.tap) map.tap.enable();
                                                document.getElementById('map').style.cursor='grab';

                                            });

                        // Prevent map from moving while we are focused on brushing
                        
                        stat_brushX.on('brush', function(){
                                                    // Keep the map static
                                                    map.dragging.disable();
                                                    map.touchZoom.disable();
                                                    map.doubleClickZoom.disable();
                                                    map.scrollWheelZoom.disable();
                                                    map.boxZoom.disable();
                                                    map.keyboard.disable();
                                                    if (map.tap) map.tap.disable();
                                                    document.getElementById('map').style.cursor='default';
                                                });
                        
                        stat_brush_g.call(stat_brushX);

                    });

            feature.on('click', function(d, i){
                d3.selectAll('.province')
                    .style('fill-opacity', 0);
                d3.select(this).style('fill-opacity', 0.6);
            });
            
            let bounds = gen_path.bounds(results[0]);
            let top_left = bounds[0];
            let bottom_right = bounds[1];

            svg.attr('width', bottom_right[0] - top_left[0])
                .attr('height', bottom_right[1] - top_left[1])
                .style('left', top_left[0] + 'px')
                .style('top', top_left[1] + 'px');

            g.attr('transform', 'translate(' + -top_left[0] + ',' + -top_left[1] + ')');


            map.on('moveend', () => {
                bounds = gen_path.bounds(results[0]);
                top_left = bounds[0];
                bottom_right = bounds[1];
                svg.attr('width', bottom_right[0] - top_left[0])
                    .attr('height', bottom_right[1] - top_left[1])
                    .style('left', top_left[0] + 'px')
                    .style('top', top_left[1] + 'px');

                g.attr('transform', 'translate(' + -top_left[0] + ',' + -top_left[1] + ')');
                feature.attr('d', gen_path);
            });

        });


	      var popup = L.popup();
        // Response to the mouse click
        map.on('click', function(e) {

            var data = {'lat': e.latlng.lat, 'lin': e.latlng.lng};

            let nearestP = nearestPoint(data);

            // do something with response
            if (canton != null){
                popup.setLatLng(e.latlng)
                .setContent("Position " + e.latlng.toString() + '\nCanton is ' + canton.toString() + '\nValue is ' + nearestP.toString())
                .openOn(map)
                canton = null
            }
            else {
                popup.setLatLng(e.latlng)
                .setContent("Position " + e.latlng.toString() + '\nValue is ' + nearestP.toString())
                .openOn(map)
            }

        });

        // Declare radiobuttons listeners
        let radioButtons = document.getElementsByName("myRadios");
        radioButtons[0].checked = true;
        let prev = {
          value: "0"
        };
        map.addLayer(lyr0);
        let currentLayer = eval("lyr" + prev.value);

        for(var i = 0; i < radioButtons.length; i++) {
          radioButtons[i].addEventListener('change', function() {
            if(this.value !== "null") {
              if(currentLayer !== undefined) {
                map.removeLayer(eval("lyr" + prev.value));
              };

              prev = this;
              currentLayer = eval("lyr" + this.value);
              map.addLayer(currentLayer);
              currentLayer.bringToFront();
              createD3LegendBox(stat_svg, parseInt(this.value, 10));
            }
            if(this.value === "null") {
              map.removeLayer(currentLayer);
              currentLayer = undefined;
              removeColorBar();
            }
          });
        }

        // Declare checkbox listeners
        let checkboxHideStats = document.getElementById("hideStats");
        checkboxHideStats.addEventListener('change', () => {
          if(checkboxHideStats.checked) {
            // hide stats;
            stat_svg.attr("visibility", "hidden");
          } else {
            // show stats
            stat_svg.attr("visibility", "visible");
          }
        });

        var head = document.getElementsByTagName('head')[0];

        var script = document.createElement('script');
        script.src = "data/B_flow_retention/heat/temp.js";
        //script.src = "data/B_historical_change/heat/temp.js";
        script.type = 'text/javascript';

        head.appendChild(script)

        let heatIncrease;
        let heatDecrease;
        let checkboxIncreaseHeat = document.getElementById("increaseHeat");
        checkboxIncreaseHeat.addEventListener('change', () => {
            if(checkboxIncreaseHeat.checked) {
                heatIncrease = L.heatLayer(heatmapIncrease, {radius:7,}).addTo(map);
            } else {
                map.removeLayer(heatIncrease);
            }
        });

        let checkboxDecreaseHeat = document.getElementById("decreaseHeat");
        checkboxDecreaseHeat.addEventListener('change', () => {
            if(checkboxDecreaseHeat.checked) {
                heatDecrease = L.heatLayer(heatmapDecrease, {radius:7,  gradient : { 0.0: 'blue',
                  0.5: 'yellow',
                  1.0: 'red'}}).addTo(map);
            } else {
                map.removeLayer(heatDecrease);
            }
        });

        // Fit to overlay bounds (SW and NE points with (lat, lon))
        map.fitBounds([[9.92035336588, 101.633885799], [28.5669647084, 92.1384540862]]);

        </script>

        </body>
        </html>
